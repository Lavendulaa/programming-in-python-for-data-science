---
params:
  dynamictitle: "module2_18"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../static/module2/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)

```


```{python include=FALSE}
import pandas as pd
import numpy as np
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 15)
pd.set_option('display.max_rows', 8)

df = pd.read_csv('cereal.csv', index_col=0)
```


type: slides

# Chaining Notation  

Notes: Script here
<html>
<audio controls >
  <source src="placeholder_audio.mp3" />
</audio></html>

---

## What is Chaining?

Up until now, when we want to perform multiple actions on an object, after each action we have been saving the results under a new object name. 
Chaining allows us to do multiple actions in a single line of code without these intermediate objects. 

You can imagine that we are linking verbs together similar to a chain. 

<img src='module2/chainsfinal.png'  alt="404 image" />     
[Attribution](https://unsplash.com/photos/42ui88Qrxhw)


Notes: Script here
<html>
<audio controls >
  <source src="placeholder_audio.mp3" />
</audio></html>

---

When we made our frequency table in Module 1, we first saved the single column as an object before we used `value_counts()`.
We can do this all in one line with chaining:

```{python}
df['mfr'].value_counts()
```

However, this is not the extent of chaining.


Notes: Script here
<html>
<audio controls >
  <source src="placeholder_audio.mp3" />
</audio></html>

---

Chaining is the design of performing each method in a sequential manner. 
Let's say we want to perform 3 actions:     
1. Filter the dataframe for cereals only from manufacturer "K" 
2. Select the columns `calories`, `sugars` and `rating` using the verb `loc`.
3. Find the mean of each column using `.mean()`

Normally our code would look like this:
```{python}
mfr_k = df[df['mfr'] == 'K']
csr_df = mfr_k.loc[ : , ["calories", "sugars", "rating"]]
cereal_mean = csr_df.mean()
cereal_mean
```

Instead we can chain them:
```{python}
cereal_mean = df[df['mfr'] == 'K'].loc[ : , ["calories", "sugars", "rating"]].mean()
cereal_mean
```

This chain avoided the use of 3 intermediate objects `mfr_k`, `csr_df` and `cereal_stats`. 

Notes: Script here
<html>
<audio controls >
  <source src="placeholder_audio.mp3" />
</audio></html>

---

Great, we can cut out creating intermediate variable but now we just have a really long line of code and it's a bit hard to read.

How can we make this easier to understand?     
In this course, we suggest giving a new line for each method.  We can do this by wrapping our code in parentheses and making a new line before each period (` . `).  It's good practice to indent and have the methods line up to make it especially clear. 

```{python}
(df[df['mfr'] == 'K'].loc[ : , ["calories", "sugars", "rating"]]
                     .describe()
                     .head()
)
```

---

# Letâ€™s apply what we learned!

Notes: Script here
<html>
<audio controls >
  <source src="placeholder_audio.mp3" />
</audio></html>
