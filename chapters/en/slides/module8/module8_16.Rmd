---
params:
  dynamictitle: "module8_16"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../../static/module8/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)
Sys.setenv(RETICULATE_PYTHON = "/usr/local/bin/python3")

```


```{python include=FALSE}
import pandas as pd
import numpy as np
from sklearn.utils import shuffle
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 50)
pd.set_option('display.max_rows', 15)
cereal = pd.read_csv('cereal.csv')
cycling = pd.read_csv('cycling_data.csv')
```


type: slides


# Working with Dates and Time

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

It wasn't too long ago in Module 4, where we briefly mentioned another column dtype called `datetime64`. 

<center><img src='/module4/full.png' width="100%"></center>


Dates and times can be a bit tricky and require a specific data type so that analysis can be done correctly. 


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Let's take our cycling dataset as an example:
```{python}
cycling.head()
```
Our date column in our cycling dataframe currently has a dtype value of `object`:
```{python}
cycling.dtypes
```
Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

When we try to sort these values, it doesn't recognized the day or month values and will sort them in ascending order according to the day. 

```{python}
cycling.sort_values('Date').head(12)
```
We can see that this sorted starts with October 1st 2019 followed by September 9th 2019 and then September 10th 2019. Python is purly sorting the rows by month and not taking the day into consideration. 


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

We can try Parsing dates ourselves but that can be difficult and time-consuming. 
To demonstrate this, let's make an attempt at parsing the `Date` column in our `cycling` dataframe which currently has an `object`dtype.

```{python}
cycling.head()
```
First we would need to split the column separating the date and the time and rename the labels:

```{python}
dates = (cycling['Date'].str.split(' ', expand=True)
                           .rename(columns = {0:'Date',
                                              1:'Time'}))
dates.head()
```


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Once again, we need to split the date column and separate it into columns for the year, month and day:

```{python}
dates = (dates['Date'].str.split('-', expand=True).rename(columns = {0:'Month',
                                                                     1:'Day',
                                                                     2:'Year'}))
dates.head()
```


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Currently the values in `dates` are of type `str` so we would not be able to sort them in a temporal manner:

```{python}
dates.iloc[0,1]
```

```{python}
type(dates.iloc[0,1])
```
Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

We must convert the columns to integers values and add them to the `cycling` dataframe. 

```{python}
cycling_dates = (cycling.assign(Year = dates['Year'].astype(int),
                                Month =  dates['Month'],
                                Day = dates['Day'].astype(int))
                                )
cycling_dates.head(3)
```
We are then going to select and reorder the columns in the dataframe so the new date columns are on the left side. 

```{python}
cycling_dates = cycling_dates.loc[:, ['Year', 'Month', 'Day', 'Name',
                                      'Type', 'Time', 'Distance', 'Comments']]
cycling_dates.head(3)
```


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Now we try to sort them but how do we sort the `month` column?

```{python}
cycling_dates.sort_values(['Year', 'Month', 'Day'])
```

It now incorrectly sorts the rows by listing the October rows before September. Now we can understand that we really don't want to do it this way, right?
There are a lot of limitations, and we haven't yet separate the time. Calculating the time between dates now can also be extremely difficult. (The differing number of days in months is a contributing factor.)

Thankfully we don't have do this. Pandas has some built-in functions that will make our lives much easier. 

By the end of this slide deck, we will be able answer the question of *what was Tom's longest time between rides*. This is a question that without pandas would have taken hours, instead of minutes. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

## Pandas parse_dates

Remember How Pandas is built using the NumPy library? Well in a similar way, Pandas datetime verbs are built using the built-in Python <a href="https://docs.python.org/3/library/datetime.html" target="_blank">`datetime` library</a>. 

We can parse our data at the same time as we read in our dataframe using the argument `parse_dates`.          
Originally the `Date` column adopts a dtype of `object` when the data is read in. 

```{python}
cycling = pd.read_csv('cycling_data.csv')
cycling.head(3)
```

```{python}
cycling.dtypes
```


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Using the `parse_dates`argument with `pd.read_csv()` changes that so that it now adopts a `datetime64` dtype: 

```{python}
cycling_dates = pd.read_csv('cycling_data.csv', parse_dates = ['Date'])
cycling_dates.head()
```

```{python }
cycling_dates.dtypes
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Now that we have a datetime column which expresses when Tom began his journey, we can sort our dataframe correctly now: 
```{python}
cycling_dates.sort_values('Date')
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

As another example, our date data may be split between multiple columns: 

```{python}
pd.read_csv('cycling_data_split_time.csv').head()
```
We can combine the `Year`, `Month ` and `Day` columns to a single datetime column by using a dictionary within the `parse_dates` argument. The dictionary key, indicates the new column name and the dictionary value is a list with the multiple date columns to combine:

```{python}
(pd.read_csv('cycling_data_split_time.csv',
              parse_dates={'Date': ['Year', 'Month', 'Day', 'Clock']})
              .head())
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

What if we need to convert a column into dtype `datetime` after reading in our data? That's not a problem! We have `pd.to_datetime()` to transform columns of an already existing dataframe. 

Let's use our original `cycling` dataframe where `Date` is still of dtype `object`.
```{python}
cycling = pd.read_csv('cycling_data.csv')
cycling.head()
```

```{python}
cycling.dtypes
```


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

To convert `Date` to a datetime dtype, we use `pd.to_datetime()` and `assign()`:
```{python}
new_cycling = cycling.assign(Date = pd.to_datetime(cycling['Date']))
new_cycling.head()
```

```{python}
new_cycling.dtypes
```
Ok, but what if I don't want the full datetime value and I want a column with only a portion of it, like the month, or year? 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

No worries, we can add a new column to our dataframe in a similar as we did before but now we can extract a portion of the `datetime` column by using <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-date-components" target="_blank">one of the many pandas datetime tools</a>.
Here are a couple of examples: 

- `.dt.day_name()` for the day of the week:

```{python}
new_cycling['Date'].dt.day_name().head()
```
We can pair this with `.assign()` to add this as a column in the dataframe: 
```{python}
new_cycling.assign(weekday = new_cycling['Date'].dt.day_name()).head()
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

- `dt.day` for the day:

```{python}
new_cycling['Date'].dt.day.head()
```

Again using `.assign()` to add it to our dataframe:
```{python}
new_cycling.assign(day = new_cycling['Date'].dt.day).head()
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

There is some inconsistency with these verbs. You can see that some use parentheses `()` and some do not. Here are some of the most common useful datetime tools: 

- `dt.year`
- `dt.month`
- `dt.month_name()`
- `dt.day`
- `dt.day_name()`
- `dt.hour`
- `dt.minute`

For a full list refer to <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Timestamp.html#:~:text=Timestamp%20is%20the%20pandas%20equivalent,oriented%20data%20structures%20in%20pandas.&text=Value%20to%20be%20converted%20to%20Timestamp.&text=Offset%20which%20Timestamp%20will%20have." target="_blank">the attributes and methods section of the Timestamp documentation</a>.

Using the `.dt` portion of these can only be used on a pandas Series. We can extract the day, month, year hour, or minute from a single datetime value, using the same nouns but omitting the `dt.`.

Let's see how that's possible. 


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

```{python}
new_cycling.head()
```

If I select the first example in row 1 of our `new_cycling` dataset, you'll notice that its outputs something called a `Timestamp`. 

```{python}
timestamp_ex = new_cycling.loc[1,'Date']
timestamp_ex
```
This is a pandas data type. 


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

```{python}
timestamp_ex
```
Timestamps show a snapshot of when an event has occurred. Timestamps are complete with both dates and times. If that's not complete, Python will fill in any unknowns with default values (often with `00:00:00` for time, if only the date was provided). 

To obtain the month name, day, or hour from the Timestamp, we can use the same nouns in the previous slide without `.dt.`:

```{python}
timestamp_ex.month_name()
```

```{python}
timestamp_ex.day
```

```{python}
timestamp_ex.hour
```


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

In our analysis it might be important to know how frequent events occur and the time between them.     
`.diff()` is a useful function for that. 

```{python}
cycling_intervals = new_cycling['Date'].sort_values().diff()
cycling_intervals
```
This outputs a pandas Series with the time that occurs between rows. As you can see there was a 10 hour and 31minute gap between Tom's second and third  bike rides. Wow - that's a long work day!"

Here, you'll now notice a new dtype at the bottom of our new pandas Series named  <a href="https://docs.python.org/2/library/datetime.html" target="_blank">`timedelta64`</a>. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

## timedelta

Unlike a `Timestamp` that represents a snapshot in time, `timedelta` represents a duration of time. 

This means that it is a measurement of time.
Here we can obtain the time  between 2 trips :

```{python}
cycling_intervals[1]
```

```{python}
cycling_intervals[1].seconds
```
Measures can only be extracted from the timedelta object using either `days`, `seconds`, and  `microseconds`. 
We can convert them into other units by using simple operations.

```{python}
sec_per_hour = 60 * 60
cycling_intervals[1].seconds / sec_per_hour
```



Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Timedelta objects have a lot of functionality. We can use summary statistic verbs with them. 
For example, we can calculate the maximum amount of time between rides:

```{python}
cycling_intervals.max()
```
As well as the minimum:
```{python}
cycling_intervals.min()
```
We can also do simple operation with them:

```{python}
interval_range = cycling_intervals.max() - cycling_intervals.min()
interval_range
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

# Let’s practice what we learned!

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
