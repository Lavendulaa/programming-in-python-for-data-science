---
params:
  dynamictitle: "module6_13"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../../static/module6/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)

```


```{python include=FALSE}
import pandas as pd
import numpy as np
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 50)
pd.set_option('display.max_rows', 15)
cereal = pd.read_csv('cereal.csv')
```


type: slides


# Defensive programming using exceptions


Notes: 

<br>

---

***Defensive programming***: Code written in such a way that if errors do occur, they are handled in a graceful, fast and informative manner. 

***Exceptions***: Used in ***Defensive programming*** to disrupts the normal flow of instructions. When Python encounters code that it cannot execute, it will throw an ***exception***.

Notes: 

We all know that mistakes are a regular part of life.

In coding, every line of code is at risk for potential errors, so naturally, we have a way of defending our functions against potential issues.        

***Defensive programming*** is code written in such a way that if errors do occur, they are handled in a graceful, fast and informative manner. 

If something goes wrong, we don't want the code to crash - we want it to fail gracefully.

To help soften the landing, we use something called ***Exceptions***.

***Exceptions*** are used in ***Defensive programming*** to disrupts the normal flow of instructions. When Python encounters code that it cannot execute, it will throw an ***exception***.

---



```{python}
def exponent_a_list(numerical_list, exponent=2):
    new_exponent_list = list()
    for number in numerical_list:
        new_exponent_list.append(number ** exponent)
    return new_exponent_list
```

```{python eval=FALSE}
numerical_string = "123"
exponent_a_list(numerical_string)
```
```out
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

Detailed traceback: 
  File "<string>", line 1, in <module>
  File "<string>", line 4, in exponent_a_list
```



Notes: 

Before we dive into exceptions, let's revisit our function `exponent_a_list()`. 

It work somewhat well but what happens if we try to use it with a input string instead of a list.

We get an error that explains a little bit of what's causing the issue but not directly. 

This is where raising an `Exception` steps in to help.

---

## Exceptions

```{python}
def exponent_a_list(numerical_list, exponent=2):

    if type(numerical_list) is not list:
        raise Exception("You are not using a list for the numerical_list input.")

    new_exponent_list = list()
    for number in numerical_list:
        new_exponent_list.append(number ** exponent)
    return new_exponent_list
```


```{python eval=FALSE}
numerical_string = "123"
exponent_a_list(numerical_string)
```
```out
Exception: You are not using a list for the numerical_list input.

Detailed traceback: 
  File "<string>", line 1, in <module>
  File "<string>", line 4, in squares_a_list
```
(Note that in the interest of avoiding new syntax we are using a simple way of checking if an object is of a certain data type. For a more robust approach see <a href="https://docs.python.org/3/library/functions.html#isinstance" target="_blank">here</a>.)

Notes: 

Exceptions disrupt the regular execution of our code. When we raise an `Exception` we are forcing our own error with our own message. 

If we wanted to raise an exception to solve the problem on the last slide, we could do the following.

---

<br> 
<br>

<center><img src='/module6/exception2.png' width="100%"></center>



Notes:

Let's take a closer look.

The first line of code specifies our condition - what needs to occurs to execute the body of the condition. 

This code translates to *"If `numerical_list` is not of the type `list`..."*.

The second line does the complaining.

We tell it to `raise` an `Exception` (throw an error) with this message. 

Now we get an error message that is straightforward on why our code is failing.

`Exception: You are not using a list for the numerical_list input.`

We can agree that this message is easier to decipher than the original.

he new message made the cause of the error much clearer to the user making our function much more usable.


---

## Why raise Exceptions

```python
if type(numerical_list) is not list:
        raise Exception("You are not using a list for the numerical_list input.")
```

Notes: 


Here we checks if `numerical_list` is of the type we expect it to be, in this case a `list`. 

Checking the datatype is a helpful exception since the user can quickly correct for a simple mistake.



---

```{python}
def exponent_a_list(numerical_list, exponent=2):
    
    for element in numerical_list: 
        if not element >= 0:
            raise Exception("The elements in numerical_list must all be positive values")

    new_exponent_list = list()
    for number in numerical_list:
        new_exponent_list.append(number ** exponent)
    return new_exponent_list
```

```python
wrong_list = [1, -2, 3.4]
exponent_a_list(wrong_list, 2)
```
```out
Exception: The elements in numerical_list must all be positive values

Detailed traceback: 
  File "<string>", line 1, in <module>
  File "<string>", line 5, in exponent_a_list
```
Notes:

Another good thing to check for our function is if all the elements in the list are not negative numbers.

We can use comprehension that we learned in the last module to check that each element is greater or equal to 0. 

If not all of them are, an `Exception` will be raised.

---

## Exception types

```python
if type(numerical_list) is not list:
        raise Exception("You are not using a list for the numerical_list input.")
```

<a href="https://docs.python.org/3/library/exceptions.html#Exception" target="_blank">  Here is a full list containing other types of exceptions available</a>.

Notes:

We discussed the conditional part of an exception, but now let's learn more about the possible different types of Exceptions. 

The exception type called `Exception` is a generic, catch-all exception type.

There are also<a href="https://docs.python.org/3/library/exceptions.html#Exception" target="_blank"> many other </a> exception options; for example, you may have encountered `ValueError` or a `TypeError` at some point.

`Exception` which is used in our previous examples may not be the best option for the raises we made. 






---
 
 ```python
if type(numerical_list) is not list:
        raise Exception("You are not using a list for the numerical_list input.")
```


```{python}
def exponent_a_list(numerical_list, exponent=2):

    if type(numerical_list) is not list:
        raise TypeError("You are not using a list for the numerical_list input.")

    new_exponent_list = list()
    for number in numerical_list:
        new_exponent_list.append(number ** exponent)
    return new_exponent_list
```

```python
numerical_string = "123"
exponent_a_list(numerical_string)
```
```out
TypeError: You are not using a list for the numerical_list input.

Detailed traceback: 
  File "<string>", line 1, in <module>
  File "<string>", line 4, in exponent_a_list
```

For the full list of exception types take a look at <a href="https://docs.python.org/3/library/exceptions.html" target="_blank">this resource</a>. 

Notes: 

Let's take a look now at the exception we wrote that checks if the input value for `numerical_list` was the correct type.

Since this is a type error, a better raised exception over `Exception` would be `TypeError`.

Let's make our correction here and change `Exception` in our function to `TypeError`.

---

## Exception Documentation

```{python}
def exponent_a_list(numerical_list, exponent=2):
    """
    Creates a new list containing specified exponential values of the input list. 
    
    Parameters
    ----------
    numerical_list : list
        The list from which to calculate exponential values from
    exponent : int or float, optional
        The exponent value (the default is 2, which implies the square).
        
    Returns
    -------
    new_exponent_list : list
        A new list containing the exponential value specified of each 
        of the elements from the input list 
        
    Raises
    ------
    TypeError
      If the input argument numerical_list is not of type list
        
    Examples
    --------
    >>> squares_a_list([1, 2, 3, 4])
    [1, 4, 9, 16]
    """
```



Notes:

Now that we can write exceptions it's important to document them.

We've learned that documenting your functions with docstrings is important so it should come to no surprise that it's a good idea to include details of any included exceptions in our function's docstring. 

Under the NumPy format, we explain our raised exception after the "***Returns***" section. 

We first specify the exception type and then an explanation of what causes the exception to be raised. 

For example we've added a raises section in our `exponent_a_list` docstring here.

---


# Letâ€™s apply what we learned!

Notes: 

<br>