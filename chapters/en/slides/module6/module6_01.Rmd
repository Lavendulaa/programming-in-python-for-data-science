---
params:
  dynamictitle: "module6_01"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../../static/module4/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)

```


```{python include=FALSE}
import pandas as pd
import numpy as np
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 50)
pd.set_option('display.max_rows', 15)
cereal = pd.read_csv('cereal.csv')
```


type: slides


# DRY revisited and function fundamentals

Notes: 

<br>

---

```{python}
numbers = [2, 3, 5]
squared = list()
for number in numbers: 
    squared.append(number ** 2)
squared
```

```{python}
def squares_a_list(numerical_list):
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
    return new_squared_list
```

```{python}
squares_a_list(numbers)
```

Notes: 

In the last module, we were introduced to the DRY principle and how creating functions helps comply with it. 

Let's do a little bit of a recap.

**DRY** stands for Don't Repeat Yourself. 

We can avoid writing repetitive code by creating a function that takes in arguments, performs some operations and returns the results. 

The example in Module 5 converted code that creates a list of squared elements from an existing list of numbers, into a function.

---

```{python}
larger_numbers = [5, 44, 55, 23, 11]
promoted_numbers = [73, 84, 95]
executive_numbers = [100, 121, 250, 103, 183, 222, 214]
```

```{python}
squares_a_list(larger_numbers)
```

```{python}
squares_a_list(promoted_numbers)
```

```{python}
squares_a_list(executive_numbers)
```



Notes:

This function gave us the ability to do the same operation for multiple lists without having to rewrite any code and just calling the function.

---

## Scoping

      
```{python}
def squares_a_list(numerical_list):
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
        print(new_squared_list)
    return new_squared_list
```

```{python}
squares_a_list(numbers)
```


```python
new_squared_list
```

```out
NameError: name 'new_squared_list' is not defined

Detailed traceback: 
  File "<string>", line 1, in <module>
```

```{python}
a_new_variable = "Peek-a-boo"
```

Notes:

It's important to know what exactly is going on inside and outside of a function.

In our function `squares_a_list()` we saw that we created a variable named `new_squared_list`. 

We can print this variable and watch all the elements be appended to it as we loop through the input list.

But what happens if we try and print this variable outside of the function? 

Yikes! Where did `new_squared_list` go?

It doesn't seem to exist! That's not entirely true. 

In Python, `new_squared_list` is something we call a ***local variable***. 

Local variables are any objects that have been created within a function and only exist inside the function where they are made. 

Code within a function is described as a **local environment**.

Since we called `new_squared_list` outside of the function's body, Python fails to recognize it. 

Let's compare that with the variable `a_new_variable`. 

`a_new_variable`  is created outside of a function in what we call our ***global environment*** and therefore Python recognizes it as a ***global variable***.

---

## Global and Local Variables 

```{python}
def squares_a_list(numerical_list):

    print(a_new_variable)
    
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
    return new_squared_list
```

```{python}
squares_a_list([12, 5, 7, 99999])
```



Notes: 

Global variables differ from local variables as they are not only recognized outside of any function but also recognized inside functions.  

Let's take a look what happens when we add `a_new_variable`, which is a global variabl,e and refer to it in the `squares_a_list` function.

The function recognizes the global variable! 

It's important to note that, although functions recognize global variables, it's not good practice to have functions reference objects outside of it. 

We will learn more about this later in the module. 

---

<br>
<br>
<br>


<center><img src='/module6/starbucks.png' width="100%" alt="404 image"></center>  

[Attribution - Starbucks](https://unsplash.com/photos/42ui88Qrxhw)

[Attribution - 49th and Parallel](https://unsplash.com/photos/42ui88Qrxhw)

Notes: 

I'm going to make an analogy comparing coffee stores to variables. 

**Starbucks Coffee** is a ***globally*** recognized brand across the world and is available in 70 different countries. 

I can purchase a coffee from Starbucks in Vancouver (my local city) and if I were to travel across the world to Sydney, Australia, I would still be able to purchase a coffee from Starbucks there. 

Starbucks Coffee is similar to a global variable as it is accessible and recognized in both its local (Vancouver) and global environments. 

**49th Parallel** is a ***local*** Vancouver coffee store. 

Many people from Vancouver recognize it, however, purchasing a coffee from 49th Parallel outside of Vancouver would be impossible as it is not accessible past the City of Vancouver. 

Just like Starbucks Coffee, global variables are recognized and accessible in both their global and local environments, whereas local variables like the coffee store 49th Parallel are only recognized and accessible in the local environment it was created in. 

---

## When things get tricky


```{python}
a_new_variable = "Peek-a-boo"
```



```{python}
def squares_a_list(numerical_list):
    a_new_variable = "Ta-Da!"
    print(a_new_variable)
    
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
    return new_squared_list
```

```{python}
squares_a_list([1, 2])
```

```python
squares_a_list([1, 2])
a_new_variable
```
```out
Ta-Da!
[1, 4]
'Peek-a-boo'
```

Notes:

Things can get unclear when we have variables that are named the same way but come from two different environments. 

What happens when 2 different objects share the same name, where one was defined inside the function and the other in the global environment? 

For instance, let's say we defined a variable `a_new_variable` in our global environment, and we've made a variable in a local environment with the same name `a_new_variable` but with different values within our `squares_a_list` function.

We can see that the locally created `a_new_variable` variable was printed instead of the global object with the same name. 

What about if we output `a_new_variable` right after.

Our function prints the locally defined `a_new_variable`, and the global environment prints the globally defined `a_new_variable`. 

---

```{python}
def squares_a_list(numerical_list, a_new_variable):
    print(a_new_variable)
    
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
    return new_squared_list
```




```{python}
a_new_variable = "Peek-a-boo"
squares_a_list([1,2], "BAM!")
```


Notes: 

What if `a_new_variable` was an argument? 

Given a global variable `a_new_variable = "Peek-a-boo"`, what value will the function print if we assign a value of `"BAM!"` to the input argument `a_new_variable`? 

Here we can see that the function uses the input argument value instead of the global variable value. 

---

## Modifying global variables 



```{python}
global_list = [50, 51, 52]
```

```{python}
def squares_a_list(numerical_list):
    global_list.append(99)
    print("print global_list:", global_list)
    
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
    return new_squared_list
```

```{python error=TRUE}
squares_a_list([1, 2])
global_list
```


Notes:

So global variables are accessible inside functions - but what about modifying them? 

Let's take a list that we define in our global environment called `global_list` and add `99` to the list in the local environment. 

The list that we defined globally was able to be modified inside the function and have the changes reflected back in the global environment! 

What is going on? 

Modifying objects like this within a function without returning them is called a function **side effect**.

---

## Function Side Effects 

```{python eval = FALSE}
cereal.to_csv('cereal.csv')
```


```{python}
def squares_a_list(numerical_list):
    new_squared_list = list()
    for number in numerical_list:
        new_squared_list.append(number ** 2)
        print(new_squared_list)
    return new_squared_list
```

```{python}
numbers = [2, 3, 5]
squares_a_list(numbers)
```


Notes: 


Although this appears to be new vocabulary, side effects have been present since the beginning of this course starting with `pd.to_csv()`. 

Remember our cereal dataframe? 

Well we've edited it and now want to save it to our computer. 

We can use `pd.to_csv()` like this:

When we execute this code, nothing is returned but we get a **side effect** of a newly saved csv file on our computer. 

Printing anything in a function is also considered a function side effect.

Even though this operation doesn't affect any of your global variables, it does bring information from within the function to the outside world. 

---

```{python}
def value_change(data, column, old_value, new_value):
    data.loc[data[column] == old_value, column] = new_value
```

```{python include = FALSE}
cereal = pd.read_csv('cereal.csv').loc[:, 'name':'calories']
```

```{python}
cereal.head()
```

```{python}
value_change(cereal, 'type', 'Cold', 'Unheated')
```

Notes: 

The same can be said anytime we modify a dataframe within a function without returning anything. 

Let's say we have the following function that does conditional value replacement on a specified column.    

It takes as inputs:    

- The dataframe     
- the column we want to edit     
- the value that we wish to replace      
- the new value we wish to use as a replacement     

And returns nothing.


Using a slice of our cereal dataset, let's change all the values that have `type` as `Cold` to `Unheated` using  the `value_change` function.

We can see that our function has no `return` statement and thus the code above produces no output but let's look at what happens when we look at the cereal dataset after calling the function on it.

---

```{python}
cereal
```

Notes:

It looks like our `Cold` values were changed even without returning anything in our function! 

This would be another example of a function side effect. 

Variables are modified by the function outside the environment the object originated from. 

The dataframe was created in the global environment, but modified in the function's local environment. 

---

## Good Habits 

```{python include =FALSE}
cereal = pd.read_csv('cereal.csv').loc[:, 'name':'calories']
```


```{python}
def better_value_change(data, column, old_value, new_value):
    new_dataframe2 = data.copy()
    new_dataframe2.loc[new_dataframe2[column] == old_value, column] = new_value
    return new_dataframe2
    
```


```{python}
unheated_cereal = better_value_change(cereal, 'type', 'Cold', 'unheated')
```


```{python}
cereal.head()
```

Notes: 

Side effects seem like fun but they can be extremely problematic when trying to debug (fix) your code. 

When writing functions, it's usually a good idea to avoid side effects. 

If objects need to be modified, best practice is to modify them in the environment they originated in. 

For example, you wish to write a better version of the `value_change()` function above, a more acceptable way would be to return a new dataframe that was produced and modified from a copy of the original dataframe in the local environment. 

We can make a copy of the original dataframe using `.copy()`.

We can then call our new better function `better_value_change` with our input arguments. 

This time our original original dataframe hasn't been changed.

---


```{python}
unheated_cereal.head()
```

Notes: 

Instead, the output from our function that we saved in the object `unheated_cereal` has the desired changes.

---

## Side Effect Documentation 


- If your functions have side-effects, they should be documented. 



Notes: 

Although side effects are not recommended, there are cases where either we must have a side-effects in our functions or there is no way to avoid it. In these cases, it is extremely important that we document it. 


This leads to the next question of *How*? Good news - the answer is coming later on in this module! 


---


# Let’s apply what we learned!

Notes: 

<br>