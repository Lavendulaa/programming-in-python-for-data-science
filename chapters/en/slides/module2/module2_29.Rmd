---
params:
  dynamictitle: "module2_24"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../../../../static/module2/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)


```


```{python include=FALSE}
import pandas as pd
import numpy as np
import altair as alt
from altair_saver import save
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 50)
pd.set_option('display.max_rows', 15)

df = pd.read_csv('cereal.csv')
cereal = df

## Adjusted path 
path = "../../../../static/module2/"
```


type: slides

# Plotting Groupby Objects


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Let's learn some other useful abilities of `altair`. When specifying `x` and `y` in the `encode(..)` function, altair allows us to specify what data type to expect. See the table below for a description of the data types available and how to specify them.

| Data Type   | Shorthand Code | Description |
| ----------- | ----------- | ----------- |
| Quantitative | `Q` |  a continuous real-valued quantity |
| Ordinal   | `O` | a discrete ordered quantity |
| Nominal | `N` | a discrete unordered quantity |
| Temporal| `T` | a time or date value |

Ordinal values imply that there is some natural ordering to the values. For example, the ratings a movie receives is on an ordinal scale since a five star rating is better than a single star rating. In contrast, there is no such natural ordering for nominal values. An example of this would be strings.

Altair is sometimes smart enough to tell which data type the input is. For example, `strings` are considered as `nominal`, anything `numeric` will be considered as `quantitative` and `time` values are considered as `temporal`. We will see examples of temporal data types in module 8. However, these defaults may not always be correct. In the next slide, we will see an example of specifying data types when plotting.

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Now let's say we are interested in plotting the sugar content in cereals from each manufacturer. We do this using a `bar` plot which we are quite familiar with to do this, we will be using the `mfr` column and the `sugars` column from the `cereal` dataframe we have been using. 

Here, `mfr` is a categorical column (remember this explanation from module 1?). This is because there is no specific order in which cereal type must come before another. For example, it is not the case that "Kelloggs" must come before “Quaker”. Because of this, the `mfr` column is categorized as a Nominal data type. The `sugars` column in contrast, is categorized as quantitative column. It is a quantitative column since it is a quantitative measurement that takes on any positive integer value.

```{python}
chart1 = alt.Chart(cereal, width=500, height=300).mark_bar().encode(
    x='mfr:N', # set the manufacturer column as nominal
    y='sugars:Q' # set the sugars column as quantitative
).properties(title="Bar plot of manufacturer sugar content")
chart1

```


```{python include =FALSE}
chart1.save(path + 'chart1.png')
```

<img src="/module2/chart1.png" alt="A caption" width="40%" />


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

So far when plotting with altair, we have been mapping our `x` and `y` in the `encode(x=..,y=..)` function. However, doing so gives us very little control on how exactly we would like to map our x and y values. In order to have more control, we can map our x and y values using the `x=alt.X(...)` and `y=alt.Y(...)` respectively. This gives us a lot more control over how values are mapped in the resulting plot. Let's generate the plot on the previous slide using the method.


```{python}
chart2 = alt.Chart(cereal, width=500, height=300).mark_bar().encode(
    x=alt.X('mfr:N'), # use alt.X() to map the x-axis
    y=alt.Y('sugars:Q') # use alt.Y() to map the y-axis
).properties(title="Bar plot of manufacturer sugar content")
chart2

```


```{python include =FALSE}
chart2.save(path + 'chart2.png')
```

<img src="/module2/chart2.png" alt="A caption" width="40%" />


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Another interesting thing we can do with this new syntax is change the number of `bins` when generating a bar plot. Having control over the number of bins in a bar plot may help to make visualization easier which will make the plots easier to digest.  If we wanted to change the number of bins, we can use the `bin=alt.Bin(maxbins=..)` in `alt.X()` to set a value for the number of bins. For example, we can generate a bar plot of the `calories` column in the cereal dataframe and set the number of bins to `50` by setting `bin=alt.Bin(maxbins=50)`.


```{python}
chart3 = alt.Chart(cereal, width=500, height=300).mark_bar().encode(
    x=alt.X('calories:Q', bin=alt.Bin(maxbins=50)), # set max number of bins to 50
    y=alt.Y('count():Q')
).properties(title="Bar plot of cereal calory content")
chart3

```


```{python include =FALSE}
chart3.save(path + 'chart3.png')
```

<img src="/module2/chart3.png" alt="A caption" width="40%" />


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

The `x` and `y` labels from the bar plot on the previous slide are not very informative. Luckily, using the same syntax, we can set custom axis `titles` using the `title=""` argument. Let's see how this works by providing more informative titles to the plot from the previous slide.

```{python}
chart4 = alt.Chart(cereal, width=500, height=300).mark_bar().encode(
    x=alt.X('calories:Q', bin=alt.Bin(maxbins=50), title="Calory content"), # Change the axis title
    y=alt.Y('count():Q', title="Count") # Change the axis title
).properties(title="Bar plot of cereal calory content")
chart4

```


```{python include =FALSE}
chart4.save(path + 'chart4.png')
```

<img src="/module2/chart4.png" alt="A caption" width="40%" />


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Let's return to the question we asked at the beginning slides of exercise 25: 

_*Which manufacturer has the highest mean sugar content?*_   

A nice way of showing our results would be to graph this. A bar chart like this should do the trick! However, before doing this, we need a few tricks under our belt. At the beginning slides of exercise 25, we used the `groupby(by='mfr')` function and then took the `mean()` to compute these values. Lets see what the resulting dataframe looks like.


```{python}
sugar_df = pd.DataFrame(cereal.groupby(by='mfr').mean().loc[:, 'sugars'])
sugar_df
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Notice in the previous slide that `mfr` has now moved to the left of the dataframe and the label is lower now than the other column labels? This is because when you apply `groupby()` to a column, this column becomes the new dataframe index. Although this is a useful feature in many cases, Altair cannot access the column names of index columns. To deal with this, we use `reset_index()` which will convert `mfr`  to a regular column again. See below:

```{python}
sugar_df.reset_index(inplace=True)
sugar_df
```

Notice now that the `mfr` column has moved up and next to the `sugars` column. The index has also been replaced with integers. Now that our dataframe is in this form, we are able to proceed in plotting the mean sugar content for each manufacturer. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Now that we have our `sugar_df` in the correct format, we can proceed to plot the mean sugar content for each manufacturer.

```{python}
chart5 = alt.Chart(cereal, width=500, height=300).mark_bar().encode(
    x=alt.X('mfr:N', title="Manufacturer"),
    y=alt.Y('sugars:Q', title="Mean sugar content")
).properties(title="Bar plot of manufacturers mean sugar content")
chart5

```


```{python include =FALSE}
chart5.save(path + 'chart5.png')
```

<img src="/module2/chart5.png" alt="A caption" width="40%" />


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Let's go through the steps that were needed to make the plot in the previous slide. 

- We created a groupby object and calculated the mean for each column in the resulting dataframe.       
- Next, we took the single column we are interested in using `.loc[]`.
- Since grouping by made `mfr` the new index, we had to use `reset_index(inplace=True)` to make `mfr` a column again.
- Our last action was to generate a bar plot using altair. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

<!-- We've added a title before, so there is nothing new there but adding x and y-axis labels is a little different. We can increase the label font sizes using the argument `fontsize`. In this case, we reference our initial plot and use the verb `.set_ylabel()` and `.set_xlabel()` with the desired axis label as an argument and `fontsize` to assign a desired label size.  -->
<!-- To avoid unnecessary information that will be returned otherwise, whatever our last verb being used with our plot (named `sugar_plot) has to be reassigned back to the object. If we did this any other way, we would not have the ability to do more transformations on our plot, or we would get additional information with the plot output.  -->

<!-- ```{python  out.width = '45%', fig.asp = .40} -->
<!-- sugar_plot = (df.groupby(by='mfr') -->
<!--                 .mean() -->
<!--                 .loc[:,'sugars'] -->
<!--                 .plot.bar(title='Mean sugar content among manufacturers') -->
<!--               ) -->
<!-- sugar_plot.set_ylabel('Sugar content (in grams)', fontsize=9) -->
<!-- sugar_plot = sugar_plot.set_xlabel('Manufacturer', fontsize=9) -->
<!-- sugar_plot -->
<!-- ``` -->



<!-- Notes: Script here -->
<!-- <html> -->
<!-- <audio controls > -->
<!--   <source src="/placeholder_audio.mp3" /> -->
<!-- </audio></html> -->

<!-- --- -->

<!-- In the last plot, we used `.loc[:,'sugars']` to select a single column to the plot, however, we can show multiple mean column values in a single plot by selecting more columns. The columns `fat`, `fiber` and `protein` seem like good choices.  -->

<!-- ```{python out.width = '60%', fig.asp = .58} -->
<!-- nutrition_plot = (df.groupby(by='mfr') -->
<!--                     .mean() -->
<!--                     .loc[:, ['fat', 'fiber', 'protein']] -->
<!--                     .plot.bar(title='Mean nutritrion value over different manufacturers') -->
<!--                  ) -->
<!-- nutrition_plot.set_ylabel('Content (in grams)', fontsize=9) -->
<!-- nutrition_plot = nutrition_plot.set_xlabel('Manufacturer', fontsize=9) -->
<!-- nutrition_plot -->
<!-- ``` -->


<!-- If you want high fibre and low fat, consider having N's cereals for breakfast (or lunch or dinner)! -->

<!-- Notes: Script here -->
<!-- <html> -->
<!-- <audio controls > -->
<!--   <source src="/placeholder_audio.mp3" /> -->
<!-- </audio></html> -->

<!-- --- -->

<!-- ## Multiple Grouping  -->

<!-- We can group by multiple columns as well.  -->
<!-- For example we can grouping by not only manufacturer but also by cereal type! All we do is put both both column labels in square brackets within `.groupby()`. -->

<!-- ```{python} -->
<!-- mfr_type_group = df.groupby(by=['mfr', 'type']) -->
<!-- mfr_type_group.groups -->
<!-- ``` -->

<!-- The attribute `ngroups` indicates how many groups there are.   -->

<!-- ```{python} -->
<!-- mfr_type_group.ngroups -->
<!-- ``` -->


<!-- Notes: Script here -->
<!-- <html> -->
<!-- <audio controls > -->
<!--   <source src="/placeholder_audio.mp3" /> -->
<!-- </audio></html> -->

<!-- --- -->

<!-- If we want to get the dataframe of a specific group now, we put the value of each column in parentheses.  -->

<!-- ```{python} -->
<!-- mfr_type_group.get_group(('K', 'Cold')) -->
<!-- ``` -->


<!-- Notes: Script here -->
<!-- <html> -->
<!-- <audio controls > -->
<!--   <source src="/placeholder_audio.mp3" /> -->
<!-- </audio></html> -->

<!-- --- -->

<!-- We can plot in the same way as before  -->

<!-- ```{python fig.width = 13, fig.height = 9,  out.width = '50%'} -->
<!-- type_plot = (df.groupby(by=['mfr', 'type']) -->
<!--                     .mean() -->
<!--                     .loc[:, ['sugars']] -->
<!--                     .plot.bar(title='Mean sugar value over different manufacturers and types')) -->
<!-- type_plot.set_ylabel('Sugar (in grams)', fontsize=16) -->
<!-- type_plot.set_xlabel('Manufacturer and cereal type', fontsize=16) -->
<!-- type_plot -->
<!-- ``` -->




<!-- Notes: Script here -->
<!-- <html> -->
<!-- <audio controls > -->
<!--   <source src="/placeholder_audio.mp3" /> -->
<!-- </audio></html> -->

<!-- --- -->

If all this excites you and you wish to learn more advanced visualization using **Altair**, come back soon and visit our in development course **DSCI-031 Exploratory Data Visualization**. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---



# Let’s apply what we learned!

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>
