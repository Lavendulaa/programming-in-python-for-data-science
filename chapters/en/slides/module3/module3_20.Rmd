---
params:
  dynamictitle: "module3_20"
title: "`r params$dynamictitle`"
output: 
  md_document:
    variant: gfm
---


```{r setup, include=FALSE}
## DO NOT FORGET TO CHANGE THIS ACCORDINGLY 
library(rmarkdown)
# MAke sure you are updating your title 
knitr::opts_chunk$set(echo = TRUE,
                      base.dir = ".", 
                      base.url = "/",
                      fig.path = paste("../../../static/module3/", params$dynamictitle,"/", sep = ""))

knitr_opts <- knitr_options( opts_knit = NULL,
                             opts_chunk = NULL,
                             knit_hooks = NULL,
                             opts_hooks = NULL,
                             opts_template = NULL)
md_document_custom <- md_document(variant = "gfm")
output_format(knitr = knitr_opts,
              pandoc = NULL,
              base_format = md_document_custom)
library(reticulate)

```


```{python include=FALSE}
import pandas as pd
import numpy as np
pd.set_option('display.width', 350)

np.set_printoptions(linewidth=400)

pd.set_option('display.max_columns', 50)
pd.set_option('display.max_rows', 15)

candy = pd.read_csv('candybars.csv', index_col=0)
cereal = pd.read_csv('cereal.csv', index_col=0)
```


type: slides

# Merge

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

We discussed concatenation in the last section and it covers several things so what would we need a second verb for? 
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.merge.html" target="_blank">`.merge()`</a> gives more joining options and unlike `pd.concat()`, where we identify alike rows purely on the index labels,  `.merge()` can select which column to use as the identifier in each dataframe. 


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

## Column Identifier  

`.merge()` give more versatility when assigning columns to act as connect between the dataframes.  For example, we can use the index on one dataframe and a column label on the other, indexes from both dataframes or no indexes at all to make a connection between the two dataframes. 

Let bring back the candy bar dataset to explain this concept further. 

```{python}
candy = pd.read_csv('candybars.csv', index_col=0)
candy.head()
```

`Candy` has an index label of `name` which has unique candy bar names. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

Let's load in the next dataset.

```{python}
candy2m = pd.read_csv('candybars_merge.csv', index_col=0)
candy2m
```

 This dataframe has new columns and three new rows not in the `candy` dataframe (`Kinder Bueno`, `5th Avenue`, `Crunch`)
 The column name that identifies the rows is named `chocolate_bar`, something quite different than `name` index from `candy`.   
 If we were to use `pd.concat()` to join `candy` and `candy2m` it would be a little challenging, however `.merge()` makes this a little easier for us.  

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

When we use merge it's quite different than `pd.concat()`. 
First we decide which dataframe will be our left dataframe by implementing the merge verb on the selected dataframe. We are going to choose `candy` as our left dataframe.

```python
candy.merge(...)
```

Next, we specify the right dataframe as the first argument in `.merge()`. In our case, thats `candy2m`.

```python
candy.merge(candy2m, ...)
```

The last step, which is the bulk of the work, is specifying the arguments. 
We need to make sure we indicate which columns are the identifying key columns for each dataframe and what type of joining we want in our resulting dataframe. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

## Key Columns

Unlike `pd.concat()`, where dataframes are joined on common indexes, `.merge()` needs arguments that identify a common **key** column.  This is a column present in both dataframes which contain common values.  Key columns can be an index, a regular column, or a combination of both.     

For example:  
Dataframe A can have the index label `cereal` and Dataframe B could have a column (that is not the index) labeled `product_name` that both share cereal names.  We can join these two dataframes together even though Dataframe B has a different index. 

To choose our key columns, we use the following arguments:    

- `left_on` - indicates the left dataframe identifying key column label.
- `right_on` - indicates the right dataframe identifying key column label.

Or if one or both of the key columns is an index:   

- `left_index` - Set to `True` if the identifying key column is the index in the left dataframe.    
- `right_index` - Set to `True` if the identifying key column is the index in the right dataframe.  


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

In this example, our left dataframe key column is the index labeled `name` and the right dataframe's key column is `chocolate_bar`.

```{python}
candy.merge(candy2m, left_index=True, right_on='chocolate_bar')
```

Great! we've combined the 2 dataframes horizontally (in the future we will likely want to rename `chocolate_bar` and assign it as an index again).
This join uses the default `inner` join, which returns only the rows present in both dataframes.  We can change that with the argument `how`.


Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

## how

We talked about `inner` and `outer` joins from the last section but we have 2 more joins to discuss:      

- `left`: This will only output the rows that are in the left dataframe and if they are missing from the right dataframe, `NaN` values will occur. 


```{python}
candy.merge(candy2m, left_index=True, right_on='chocolate_bar', how='left')
```

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

- `right`: Will only output the rows that are in the right dataframe and if they are missing from the left dataframe, `NaN` values will occur. 

```{python}
candy.merge(candy2m, left_index=True, right_on='chocolate_bar', how='right')
```


One thing that all 4 joins have in common, is they all will have the same columns labels that came from both dataframes. 

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

## indicator

If we want to do an outer join and show all the possible rows from both dataframes there is  a useful argument called `indicator`. 
`indicator` makes a new column name `_merge` and informs us from which dataframe the row originated from. 

```{python}
candy.merge(candy2m, left_index=True, right_on='chocolate_bar', how='outer', indicator=True)
```

Here we can see three possible values `left_only`, `right_only` or `both` which informs us if the row came from the left dataframe, the right dataframe or if the row index label is shared between both dataframes.

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
</audio></html>

---

# Letâ€™s practice what we learned!

Notes: Script here
<html>
<audio controls >
  <source src="/placeholder_audio.mp3" />
